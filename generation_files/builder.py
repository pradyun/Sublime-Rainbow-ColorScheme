#!/usr/bin/python3
"""Generates the color scheme from a CSS-like definition of the color schemes.
"""

import os
import re
import sys
import plistlib
import uuid as uuid_

from collections import namedtuple
from os.path import join, splitext, basename, expanduser

# Makes non-sublime!
import ply.lex
import ply.yacc

# -- GLOBALS ------------------------------------------------------------------
AUTHOR = "Pradyun"
PACKAGE_NAME = "Color Scheme - Rainbow"
GLOBAL_SCOPE = "GLOBAL"
DEBUG = False


def get_packages_path():
    """
    """
    if sys.platform.startswith("darwin"):
        ret = "~/Library/Application Support/Sublime Text 3"
    elif sys.platform.startswith("win"):
        ret = os.path.join(os.environ["APPDATA"], "Sublime Text 3")
    elif sys.platform.startswith("linux"):
        ret = "~/.config/sublime-text-3"
    else:
        raise Exception("Unknown OS!")
    return join(expanduser(ret), "Packages")


def generate_color_scheme_from_file(file_name):
    """Generate a color-scheme from a given file.
    """
    color_scheme = ColorScheme(splitext(basename(file_name))[0])
    out_file_name = join(
        get_packages_path(), PACKAGE_NAME, (color_scheme.name + ".tmTheme")
    )
    if DEBUG:
        out_file_name += '-test'
    uuid_file_name = file_name + ".uuid"

    # Read UUID (file-system cache)
    try:
        with open(uuid_file_name) as uuid_file:
            color_scheme.uuid = uuid_file.read()
    except FileNotFoundError:
        pass

    # Load definition file
    with open(file_name) as in_file:
        text = in_file.read()

    print("Generating {!r:<17}... ".format(color_scheme.name), end="")

    # Parse it.
    parser = Parser()
    declarations = parser.parse(text)
    # Add declarations to ColorScheme
    for declaration in declarations:
        color_scheme.add(declaration)
    # Finalize ColorScheme
    color_scheme.finalize()

    # Write UUID
    with open(uuid_file_name, "w") as uuid_file:
        uuid_file.write(color_scheme.uuid)

    # Write ColorScheme
    with open(out_file_name, "w") as f:
        f.write(color_scheme.as_plist())

    print("Done!")

# -- A nice wrapper classes ---------------------------------------------------
Rule = namedtuple("Rule", "name value")
Declaration = namedtuple("Declaration", "scopes rules")


class ColorScheme(object):
    """A color scheme generated by from a definition.
    """

    def __init__(self, name, uuid=None):
        super(ColorScheme, self).__init__()
        self.name = name
        self.uuid = uuid or str(uuid_.uuid4()).upper()
        self.settings = []

        self._seen_scopes = []

    def add(self, declaration):
        """Add rules from a Declaration to the ColorScheme.
        """
        for selectors in declaration.scopes:
            scope = " ".join(selectors)
            if scope in self._seen_scopes:
                di = self.settings[self._seen_scopes.index(scope)]
            else:
                self._seen_scopes.append(scope)
                di = {"scope": scope, "settings": {}}
                self.settings.append(di)

            for rule in declaration.rules:
                di["settings"][rule.name] = rule.value

    def finalize(self):
        """Finalize the color scheme.
        """
        if GLOBAL_SCOPE in self._seen_scopes:
            index = self._seen_scopes.index(GLOBAL_SCOPE)
            del self.settings[index]["scope"]

    def as_plist(self):
        """Return the PLIST version of the color-scheme.

        For use with TextMate/Sublime Text.
        """
        color_scheme_dict = {
            "name": self.name,
            "settings": self.settings,
            "uuid": self.uuid,
        }
        return plistlib.dumps(color_scheme_dict).decode()


# -----------------------------------------------------------------------------
# Single class PLY Lexer-Parser
# -----------------------------------------------------------------------------
class Parser(object):

    def __init__(self):
        super(Parser, self).__init__()

        self.tokens = ["NAME", "COLOR", "TEXT"]
        self.literals = ",{}:;"

        # Tokens for lexer
        self.t_NAME = r"(?:[\w-]+)(?:\.[\w-]+)*"
        self.t_COLOR = r"\#[A-Fa-f0-9]{8}|\#[A-Fa-f0-9]{6}"
        self.t_ignore = " \t"

        self._lexer = ply.lex.lex(module=self)
        self._parser = ply.yacc.yacc(module=self, start="start")

    # -- PLY Lexer -----------------------------------------------------------
    def t_newline(self, t):
        r"\n"
        t.lexer.lineno += 1

    def t_TEXT(self, t):
        r"'.*?'"
        t.value = t.value[1:-1]
        return t

    def t_error(self, t):
        print("TOKEN-ERROR: Could not generate valid token on line", end=" ")
        print(t.lexer.lineno)
        raise Exception("Unable to generate token, from: " + repr(t.value))

    # -- PLY Parser -----------------------------------------------------------
    def p_error(self, t):
        print("PARSER-ERROR: Could not parse on line", end=" ")
        print(t.lexer.lineno)
        raise Exception("Unable to parse: " + repr(t))

    def p_empty(self, p):
        "empty : "

    def p_start(self, p):
        "start : zero_or_more_declaration"
        p[0] = p[1]

    def p_zero_or_more_declaration(self, p):
        """zero_or_more_declaration : zero_or_more_declaration declaration
                                    | empty
        """
        if len(p) == 2:
            p[0] = []
        else:
            p[0] = p[1] + [p[2]]

    def p_declaration(self, p):
        """declaration : one_or_more_scope_names '{' zero_or_more_rules '}'
        """
        p[0] = Declaration(p[1], p[3])

    def p_one_or_more_scope_names(self, p):
        """one_or_more_scope_names : one_or_more_scope_names ',' scope_name
                                   | scope_name
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def p_scope_name(self, p):
        """scope_name : scope_name NAME
                      | NAME
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[2]]

    def p_zero_or_more_rule(self, p):
        """zero_or_more_rules : zero_or_more_rules rule
                              | empty
        """
        if len(p) == 2:
            p[0] = []
        else:
            p[0] = p[1] + [p[2]]

    def p_rule(self, p):
        """rule : NAME ':' value ';'
        """
        p[0] = Rule(p[1], p[3])

    # No checking!
    def p_value(self, p):
        """value : COLOR
                 | TEXT
        """
        p[0] = p[1]

    # -- Actual API -----------------------------------------------------------
    def parse(self, text):
        uncommented_text = self.remove_comments(text)
        return self._parser.parse(uncommented_text, lexer=self._lexer)

    def remove_comments(self, text):
        """Removes all text after a '//' in all lines of the text
        """
        return re.sub(r"(?m)//.*($|\n)", "", text)


if __name__ == '__main__':
    generate_color_scheme_from_file("Rainbow (Light).theme-definition")
