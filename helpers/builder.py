#!/usr/bin/python3
"""Generates the color scheme from a CSS-like definition of the color schemes.

**NOTE**
This module is meant only for Python versions >= 3.4, as it uses features added
to the standard library in Python 3.4.
"""

import os
import re
import sys
import plistlib
import uuid as uuid_

from collections import namedtuple

import ply.lex
import ply.yacc

# -- GLOBALS ------------------------------------------------------------------
AUTHOR = "Pradyun"
PACKAGE_NAME = "Color Scheme - Rainbow"
GLOBAL_SCOPE = "GLOBAL"
DEBUG = False

# -- Classes ------------------------------------------------------------------
Rule = namedtuple("Rule", "name value")
Declaration = namedtuple("Declaration", "scopes rules")


class ColorScheme(object):
    """A color scheme generated by from a definition.
    """

    def __init__(self, name, uuid, author):
        super(ColorScheme, self).__init__()
        self.name = name
        self.uuid = uuid or str(uuid_.uuid4()).upper()
        self.author = author

        self.settings = []

        self._seen_scopes = []

    def add(self, declaration):
        """Add rules from a Declaration to the ColorScheme.
        """
        for selectors in declaration.scopes:
            scope = " ".join(selectors)
            if scope in self._seen_scopes:
                di = self.settings[self._seen_scopes.index(scope)]
            else:
                self._seen_scopes.append(scope)
                di = {"scope": scope, "settings": {}}
                self.settings.append(di)

            for rule in declaration.rules:
                di["settings"][rule.name] = rule.value

    def finalize(self):
        """Finalize the color scheme.
        """
        if GLOBAL_SCOPE in self._seen_scopes:
            index = self._seen_scopes.index(GLOBAL_SCOPE)
            del self.settings[index]["scope"]

    def as_dict(self):
        """Return the dictionary of the color-scheme.

        The dictionary can be written as PLIST in a relevant file for
        TextMate/Sublime Text.
        """
        return {
            "name": self.name,
            "author": self.author,
            "settings": self.settings,
            "uuid": self.uuid,
        }


# -----------------------------------------------------------------------------
# Single class PLY Lexer-Parser
# -----------------------------------------------------------------------------
class Parser(object):

    def __init__(self):
        super(Parser, self).__init__()

        self.variables = {}

        self.tokens = ["VARIABLE", "NAME", "COLOR", "TEXT"]
        self.literals = ",{}:;"

        # Tokens for lexer
        self.t_VARIABLE = r"@[\w-]+"
        self.t_NAME = r"(?:[\w-]+)(?:\.[\w-]+)*"
        self.t_COLOR = r"\#[A-Fa-f0-9]{8}|\#[A-Fa-f0-9]{6}"

        self.t_ignore = " \t"

        self._lexer = ply.lex.lex(module=self)
        self._parser = ply.yacc.yacc(module=self, start="start")

    # -- PLY Lexer -----------------------------------------------------------
    def t_newline(self, t):
        r"\n"
        t.lexer.lineno += 1

    def t_TEXT(self, t):
        r"'.*?'"
        t.value = t.value[1:-1]
        return t

    def t_error(self, t):
        raise Exception(
            "Could not generate valid token on line {}: {!r}".format(
                t.lexer.lineno, t.value
            )
        )

    # -- PLY Parser -----------------------------------------------------------
    def p_error(self, t):
        raise Exception(
            "Could not parse on line {0.lexer.lineno}: {0!r}".format(t)
        )

    def p_empty(self, p):
        "empty : "

    def p_start(self, p):
        "start : zero_or_more_declaration"
        p[0] = p[1]

    def p_zero_or_more_declaration(self, p):
        """zero_or_more_declaration : zero_or_more_declaration declaration
                                    | empty
        """
        p[0] = p[1] or []
        if len(p) > 2 and p[2] is not None:
            p[0].append(p[2])

    def p_declaration(self, p):
        """declaration : one_or_more_scope_names '{' zero_or_more_rules '}'
                       | variable_declaration
        """
        if len(p) == 2:
            p[0] = None
        else:
            p[0] = Declaration(p[1], p[3])

    def p_variable_declaration(self, p):
        """variable_declaration : VARIABLE ':' value ';'
        """
        self.variables[p[1]] = p[3]

    def p_one_or_more_scope_names(self, p):
        """one_or_more_scope_names : one_or_more_scope_names ',' scope_name
                                   | scope_name
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[3]]

    def p_scope_name(self, p):
        """scope_name : scope_name NAME
                      | NAME
        """
        if len(p) == 2:
            p[0] = [p[1]]
        else:
            p[0] = p[1] + [p[2]]

    def p_zero_or_more_rule(self, p):
        """zero_or_more_rules : zero_or_more_rules rule
                              | empty
        """
        if len(p) == 2:
            p[0] = []
        else:
            p[0] = p[1] + [p[2]]

    def p_rule(self, p):
        """rule : NAME ':' value_or_variable ';'
        """
        p[0] = Rule(p[1], p[3])

    def p_value_or_variable_VARIABLE(self, p):
        """value_or_variable : VARIABLE
        """
        if p[1] not in self.variables:
            raise Exception("Got undeclared variable: {}".format(p[1]))
        p[0] = self.variables[p[1]]

    def p_value_or_variable_as_value(self, p):
        """value_or_variable : value
        """
        p[0] = p[1]

    # No checking!
    def p_value(self, p):
        """value : COLOR
                 | TEXT
        """
        p[0] = p[1]

    # -- Actual API -----------------------------------------------------------
    def parse(self, text):
        uncommented_text = self.remove_comments(text)
        return self._parser.parse(uncommented_text, lexer=self._lexer)

    def remove_comments(self, text):
        """Removes all text after a '//' in all lines of the text
        """
        return re.sub(r"(?m)//.*($|\n)", "", text)


# -- FUNCTIONS ----------------------------------------------------------------
def _get_packages_path():
    """Because we aren't running inside Sublime Text!
    """
    if sys.platform.startswith("darwin"):
        ret = "~/Library/Application Support/Sublime Text 3"
    elif sys.platform.startswith("win"):
        ret = os.path.join(os.environ["APPDATA"], "Sublime Text 3")
    elif sys.platform.startswith("linux"):
        ret = "~/.config/sublime-text-3"
    else:
        raise Exception("Unknown OS!")
    return os.path.join(os.path.expanduser(ret), "Packages")


def generate_color_scheme_from_files(name, *files):
    """Generate a color-scheme from a given file.
    """
    uuid = None
    text_parts = []

    for file_name in files:
        file_name = os.path.join("..", "generation_files", file_name)

        uuid_file_name = file_name + ".uuid"

        # Read UUID (file-system cache), use first that we encounter
        if uuid is None:
            try:
                with open(uuid_file_name) as uuid_file:
                    uuid = uuid_file.read()
            except IOError:
                uuid = None

        # Load definition file
        with open(file_name) as in_file:
            text_parts.append(in_file.read())

    text = "".join(text_parts)
    try:
        color_scheme_dict = generate_color_scheme(name, text, uuid, AUTHOR)
    except IOError as e:
        raise Exception("Could not generate plist.") from e

    # Write UUID
    with open(uuid_file_name, "w") as uuid_file:
        uuid_file.write(uuid)

    out_file_name = os.path.join(
        _get_packages_path(), PACKAGE_NAME, (name + ".tmTheme")
    )
    if DEBUG:
        out_file_name += '-test'

    # Write ColorScheme
    print("Writing to: {!r}".format(out_file_name))
    with open(out_file_name, "wb") as f:
        plistlib.dump(color_scheme_dict, f)

    print("Done!")


def generate_color_scheme(name, text, uuid, author):
    """Generate the colour scheme from passed parameters.
    """
    color_scheme = ColorScheme(name, uuid, author)

    parser = Parser()
    declarations = parser.parse(text)

    for declaration in declarations:
        color_scheme.add(declaration)
    color_scheme.finalize()

    return color_scheme.as_dict()


if __name__ == '__main__':
    pass
